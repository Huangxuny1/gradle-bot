/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package org.gradle.bot

import com.fasterxml.jackson.databind.ObjectMapper
import com.google.inject.AbstractModule
import com.google.inject.Guice
import com.google.inject.Provides
import io.vertx.core.AbstractVerticle
import io.vertx.core.Promise
import io.vertx.core.Verticle
import io.vertx.core.Vertx
import io.vertx.core.http.HttpServerResponse
import io.vertx.core.json.Json
import io.vertx.core.spi.VerticleFactory
import io.vertx.ext.web.Router
import io.vertx.ext.web.handler.BodyHandler
import io.vertx.kotlin.core.http.httpServerOptionsOf
import org.gradle.bot.handler.GitHubEventHandler
import org.gradle.bot.handler.GitHubWebHookHandler
import org.gradle.bot.handler.IssueCommentEventHandler
import org.gradle.bot.handler.TeamCityWebHookHandler
import org.slf4j.Logger
import org.slf4j.LoggerFactory
import java.util.concurrent.Callable
import javax.inject.Inject
import javax.inject.Singleton

val objectMapper: ObjectMapper = ObjectMapper()
val logger: Logger = LoggerFactory.getLogger(Logger.ROOT_LOGGER_NAME)

fun main() {
    val vertx = Vertx.vertx()
    vertx.exceptionHandler { logger.error("", it) }
    vertx.registerVerticleFactory(GuiceVerticleFactory())
    vertx.deployVerticle(MainVerticle::class.java.name)
}

class GuiceVerticleFactory : VerticleFactory {
    private val injector = Guice.createInjector(GradleBotAppModule())

    override fun createVerticle(verticleName: String?, classLoader: ClassLoader?, promise: Promise<Callable<Verticle>>?) {
        try {
            promise!!.complete(Callable { injector.getInstance(MainVerticle::class.java) })
        } catch (e: Throwable) {
            logger.error("", e)
            promise!!.fail(e)
        }
    }

    override fun prefix(): String = MainVerticle::class.java.simpleName
}

class GradleBotAppModule : AbstractModule() {
    override fun configure() {
    }

    @Inject
    @Provides
    @Singleton
    fun githubEventHandlers(issueCommentEventHandler: IssueCommentEventHandler) =
            listOf<GitHubEventHandler<*>>(
                    issueCommentEventHandler
            )
}


class MainVerticle @Inject constructor(private val gitHubWebHookHandler: GitHubWebHookHandler,
                                       private val teamCityWebHookHandler: TeamCityWebHookHandler) : AbstractVerticle() {
    private val logger: Logger = LoggerFactory.getLogger(MainVerticle::class.java.name)

    override fun start(startFuture: Promise<Void>) {
        val router = createRouter()

        val serverOptions = httpServerOptionsOf(host = "localhost", port = 8080, ssl = false, compressionSupported = true)
        vertx.createHttpServer(serverOptions)
                .requestHandler(router)
                .listen { result ->
                    logger.info("App start result: ${result.succeeded()}")
                    if (result.succeeded()) {
                        startFuture.complete()
                    } else {
                        startFuture.fail(result.cause())
                    }
                }
    }

    private fun createRouter() = Router.router(vertx).apply {
        route("/*").handler(BodyHandler.create())
        post("/github").handler(gitHubWebHookHandler)
        post("/teamcity").handler(teamCityWebHookHandler)
        errorHandler(500) { it?.failure()?.printStackTrace() }
    }

    /**
     * Extension to the HTTP response to output JSON objects.
     */
    fun HttpServerResponse.endWithJson(obj: Any) {
        this.putHeader("Content-Type", "application/json; charset=utf-8").end(Json.encodePrettily(obj))
    }
}
